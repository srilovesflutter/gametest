<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Rocket Shooting Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            background-color: black;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let scale, gameOver, score, lastShotTime;
        let bullets = [], enemies = [], enemyBullets = [];
        let touchX = null;

        const rocket = {
            x: 0,
            y: 0,
            width: 50,
            height: 70,
            speed: 5,
            image: new Image()
        };
        rocket.image.src = 'MainFlight.png';

        const enemyImage = new Image();
        enemyImage.src = 'enemy.png';

        const blueBulletImage = new Image();
        blueBulletImage.src = 'BlueBullet.png';

        const redBulletImage = new Image();
        redBulletImage.src = 'RedBullet.png';

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            scale = Math.max(canvas.width / 800, 1);

            rocket.width = 60 * scale;
            rocket.height = 80 * scale;
            rocket.x = canvas.width / 2 - rocket.width / 2;
            rocket.y = canvas.height - rocket.height - 20;
            rocket.speed = 6 * scale;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key] = true);
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        function moveRocket() {
            if (keys['ArrowLeft'] && rocket.x > 0) rocket.x -= rocket.speed;
            if (keys['ArrowRight'] && rocket.x + rocket.width < canvas.width) rocket.x += rocket.speed;
            if (keys['ArrowUp'] && rocket.y > 0) rocket.y -= rocket.speed;
            if (keys['ArrowDown'] && rocket.y + rocket.height < canvas.height) rocket.y += rocket.speed;
            
            // Fire bullets with cooldown
            const fireRate = 300;
            if (keys[' '] && Date.now() - lastShotTime > fireRate) {
                bullets.push({
                    x: rocket.x + rocket.width / 2 - 5 * scale,
                    y: rocket.y,
                    width: 10 * scale,
                    height: 20 * scale,
                    image: blueBulletImage,
                    speed: 7 * scale
                });
                lastShotTime = Date.now();
            }
        }

        function spawnEnemy() {
            const enemyWidth = 60 * scale, enemyHeight = 60 * scale;
            const x = Math.random() * (canvas.width - enemyWidth);
            
            const newEnemy = {
                x,
                y: -enemyHeight,  // Start off-screen
                width: enemyWidth,
                height: enemyHeight,
                speed: 2 * scale
            };

            enemies.push(newEnemy);

            // Fire bullet from enemy AFTER it has moved into view
            setTimeout(() => {
                if (!gameOver && newEnemy.y + newEnemy.height > 0) {  
                    enemyBullets.push({
                        x: newEnemy.x + newEnemy.width / 2 - 5 * scale,
                        y: newEnemy.y + newEnemy.height,  // Ensure it spawns at the enemy's bottom
                        width: 10 * scale,
                        height: 20 * scale,
                        image: redBulletImage,
                        speed: 5 * scale
                    });
                }
            }, 1500);  // Wait longer to ensure enemy is visible before firing
        }


        setInterval(spawnEnemy, 2000);

        function updateBullets() {
            bullets = bullets.filter(bullet => {
                bullet.y -= bullet.speed;
                return bullet.y + bullet.height > 0;
            });

            enemyBullets = enemyBullets.filter(bullet => {
                bullet.y += bullet.speed;
                if (bullet.y > canvas.height) return false;

                if (
                    bullet.x < rocket.x + rocket.width &&
                    bullet.x + bullet.width > rocket.x &&
                    bullet.y < rocket.y + rocket.height &&
                    bullet.y + bullet.height > rocket.y
                ) {
                    gameOver = true;
                }
                return true;
            });
        }

        function updateEnemies() {
            enemies = enemies.filter(enemy => {
                enemy.y += enemy.speed;

                if (
                    enemy.x < rocket.x + rocket.width &&
                    enemy.x + enemy.width > rocket.x &&
                    enemy.y < rocket.y + rocket.height &&
                    enemy.y + enemy.height > rocket.y
                ) {
                    gameOver = true;
                }

                return enemy.y < canvas.height;
            });
        }

        function checkCollisions() {
            bullets.forEach((bullet, bIndex) => {
                enemies.forEach((enemy, eIndex) => {
                    if (
                        bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y
                    ) {
                        bullets.splice(bIndex, 1);
                        enemies.splice(eIndex, 1);
                        score += 10;
                    }
                });
            });
        }

        function drawRocket() {
            ctx.drawImage(rocket.image, rocket.x, rocket.y, rocket.width, rocket.height);
        }

        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.drawImage(bullet.image, bullet.x, bullet.y, bullet.width, bullet.height);
            });
            enemyBullets.forEach(bullet => {
                ctx.drawImage(bullet.image, bullet.x, bullet.y, bullet.width, bullet.height);
            });
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                ctx.drawImage(enemyImage, enemy.x, enemy.y, enemy.width, enemy.height);
            });
        }

        function drawScore() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; // Semi-transparent background
            ctx.fillRect(canvas.width - 160 * scale, 10 * scale, 150 * scale, 40 * scale); 

            ctx.fillStyle = 'white';
            ctx.font = `${30 * scale}px Arial`;
            ctx.textAlign = 'right'; 
            ctx.fillText(`Score: ${score}`, canvas.width - 20 * scale, 40 * scale);
        }


        function gameLoop() {
            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';  // Dark overlay
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = 'red';
                ctx.font = `${50 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 20 * scale);

                ctx.fillStyle = 'white';
                ctx.font = `${25 * scale}px Arial`;
                ctx.fillText('Press ENTER to Restart', canvas.width / 2, canvas.height / 2 + 30 * scale);
                return;
            }


            ctx.clearRect(0, 0, canvas.width, canvas.height);
            moveRocket();
            updateBullets();
            updateEnemies();
            checkCollisions();

            drawRocket();
            drawBullets();
            drawEnemies();
            drawScore();

            requestAnimationFrame(gameLoop);
        }

        function resetGame() {
            gameOver = false;
            score = 0;
            bullets = [];
            enemies = [];
            enemyBullets = [];
            rocket.x = canvas.width / 2 - rocket.width / 2;
            rocket.y = canvas.height - rocket.height - 20;
            gameLoop();
        }

        document.addEventListener('keydown', (e) => {
            if (gameOver && e.key === 'Enter') resetGame();
        });
        let touchStartX = null;
        let touchStartY = null;

        canvas.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;

            // Fire bullets if user taps without dragging
            if (e.touches.length === 1) {
                fireBullet();
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];

            if (touchStartX !== null && touchStartY !== null) {
                let deltaX = touch.clientX - touchStartX;
                let deltaY = touch.clientY - touchStartY;

                rocket.x += deltaX;
                rocket.y += deltaY;

                touchStartX = touch.clientX;
                touchStartY = touch.clientY;

                // Keep rocket within screen boundaries
                rocket.x = Math.max(0, Math.min(canvas.width - rocket.width, rocket.x));
                rocket.y = Math.max(0, Math.min(canvas.height - rocket.height, rocket.y));
            }
        });

        canvas.addEventListener('touchend', () => {
            touchStartX = null;
            touchStartY = null;
        });

        // Fire bullets on tap (without dragging)
        function fireBullet() {
            if (bullets.length < 5) {
                bullets.push({
                    x: rocket.x + rocket.width / 2 - 5 * scale,
                    y: rocket.y,
                    width: 10 * scale,
                    height: 20 * scale,
                    image: blueBulletImage,
                    speed: 7 * scale
                });
            }
        }



        lastShotTime = 0;
        gameOver = false;
        score = 0;
        gameLoop();
    </script>
</body>
</html>
