<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Responsive Rocket Shooting Game - Improved</title>
  <!-- Firebase and Telegram scripts -->
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js"></script>
  <script async src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html,
    body {
      width: 100%;
      height: 100%;
      background-color: black;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    /* (Optional) You can style any overlay elements here */
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script type="module">
    // ──────────────────────────────── Firebase & Telegram Setup ────────────────────────────────
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.2.0/firebase-app.js";
    import {
      getDatabase,
      ref,
      push,
      query,
      orderByChild,
      limitToLast,
      get,
    } from "https://www.gstatic.com/firebasejs/11.2.0/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBMVusLN5bhGncxW4PIYRaxqU6buujdf2k",
      authDomain: "flighgamescores.firebaseapp.com",
      databaseURL: "https://flighgamescores-default-rtdb.firebaseio.com",
      projectId: "flighgamescores",
      storageBucket: "flighgamescores.firebasestorage.app",
      messagingSenderId: "646294478907",
      appId: "1:646294478907:web:04cdba902ef2f5c5fe3c1e",
      measurementId: "G-6HXTYBD1TH",
    };

    // Initialize Firebase
    const appFirebase = initializeApp(firebaseConfig);
    const db = getDatabase(appFirebase);

    // ──────────────────────────────── Canvas & Global Variables ────────────────────────────────
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    let scale, gameOver, score, lastShotTime, gameStarted = false;
    let bullets = [],
      enemies = [],
      enemyBullets = [],
      explosions = []; // For explosion effects
    let animationFrameId;
    let playerName;

    // For background stars
    let stars = [];
    const STAR_COUNT = 50;

    // Audio (ensure you provide these files)
    const shootSound = new Audio("shoot.mp3");
    const explosionSound = new Audio("explosion.mp3");

    // ──────────────────────────────── Game Assets ────────────────────────────────
    const rocket = {
      x: 0,
      y: 0,
      width: 50,
      height: 70,
      speed: 5,
      image: new Image(),
    };
    rocket.image.src = "MainFlight.png";

    const enemyImage = new Image();
    enemyImage.src = "enemy.png";

    const blueBulletImage = new Image();
    blueBulletImage.src = "Bluebullet.png";

    const redBulletImage = new Image();
    redBulletImage.src = "Redbullet.png";

    // ──────────────────────────────── Initialization Functions ────────────────────────────────
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      scale = Math.max(canvas.width / 800, 1);

      // Adjust rocket properties
      rocket.width = 60 * scale;
      rocket.height = 80 * scale;
      rocket.x = canvas.width / 2 - rocket.width / 2;
      rocket.y = canvas.height - rocket.height - 20;
      rocket.speed = 6 * scale;

      // (Re)initialize stars for background
      initStars();
      drawStartScreen(); // Redraw start screen on resize
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // Initialize star field background
    function initStars() {
      stars = [];
      for (let i = 0; i < STAR_COUNT; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: Math.random() * 2 + 1,
          speed: Math.random() * 0.5 + 0.5,
        });
      }
    }

    // ──────────────────────────────── Input Handling ────────────────────────────────
    const keys = {};
    document.addEventListener("keydown", (e) => (keys[e.key] = true));
    document.addEventListener("keyup", (e) => (keys[e.key] = false));

    // Touch & Tap controls
    let touchStartX = null,
      touchStartY = null,
      touchCount = 0;
    canvas.addEventListener("touchstart", (e) => {
      touchCount++;
      if (touchCount === 2) {
        startGame();
      }
      setTimeout(() => {
        touchCount = 0;
      }, 300);
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;

      // Fire bullet on tap
      if (e.touches.length === 1) {
        fireBullet();
      }
    });

    canvas.addEventListener("touchmove", (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      if (touchStartX !== null && touchStartY !== null) {
        const deltaX = touch.clientX - touchStartX;
        const deltaY = touch.clientY - touchStartY;
        rocket.x += deltaX;
        rocket.y += deltaY;
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
        // Keep within boundaries
        rocket.x = Math.max(0, Math.min(canvas.width - rocket.width, rocket.x));
        rocket.y = Math.max(0, Math.min(canvas.height - rocket.height, rocket.y));
      }
    });

    canvas.addEventListener("touchend", () => {
      touchStartX = null;
      touchStartY = null;
    });

    // Also allow starting/restarting with Enter key
    document.addEventListener("keydown", (e) => {
      if (e.key === "Enter") startGame();
    });

    // ──────────────────────────────── Game Functions ────────────────────────────────
    function moveRocket() {
      if (keys["ArrowLeft"] && rocket.x > 0) rocket.x -= rocket.speed;
      if (keys["ArrowRight"] && rocket.x + rocket.width < canvas.width)
        rocket.x += rocket.speed;
      if (keys["ArrowUp"] && rocket.y > 0) rocket.y -= rocket.speed;
      if (keys["ArrowDown"] && rocket.y + rocket.height < canvas.height)
        rocket.y += rocket.speed;

      // Fire bullets with spacebar and cooldown
      const fireRate = 300;
      if (keys[" "] && Date.now() - lastShotTime > fireRate) {
        fireBullet();
        lastShotTime = Date.now();
      }
    }

    function fireBullet() {
      // Limit max bullets onscreen
      if (bullets.length < 5) {
        bullets.push({
          x: rocket.x + rocket.width / 2 - 5 * scale,
          y: rocket.y,
          width: 10 * scale,
          height: 20 * scale,
          image: blueBulletImage,
          speed: 7 * scale,
        });
        // Play shoot sound
        shootSound.currentTime = 0;
        shootSound.play();
      }
    }

    // Spawn enemy with increasing speed based on score
    function spawnEnemy() {
      const enemyWidth = 60 * scale,
        enemyHeight = 60 * scale;
      const x = Math.random() * (canvas.width - enemyWidth);
      // Increase enemy speed with score (difficulty)
      const baseSpeed = 2 * scale;
      const enemySpeed = baseSpeed + score / 100;

      const newEnemy = {
        x,
        y: -enemyHeight,
        width: enemyWidth,
        height: enemyHeight,
        speed: enemySpeed,
      };
      enemies.push(newEnemy);

      // Enemy fires a bullet after a delay (if still onscreen)
      setTimeout(() => {
        if (!gameOver && newEnemy.y + newEnemy.height > 0) {
          enemyBullets.push({
            x: newEnemy.x + newEnemy.width / 2 - 5 * scale,
            y: newEnemy.y + newEnemy.height,
            width: 10 * scale,
            height: 20 * scale,
            image: redBulletImage,
            speed: 5 * scale,
          });
        }
      }, 1500);
    }

    // Instead of a fixed setInterval, we adjust spawn timing in the game loop
    let enemySpawnTimer = 0;
    let enemySpawnInterval = 2000; // milliseconds

    // Update bullets
    function updateBullets() {
      bullets = bullets.filter((bullet) => {
        bullet.y -= bullet.speed;
        return bullet.y + bullet.height > 0;
      });

      enemyBullets = enemyBullets.filter((bullet) => {
        bullet.y += bullet.speed;
        if (bullet.y > canvas.height) return false;
        // Check collision with rocket
        if (
          bullet.x < rocket.x + rocket.width &&
          bullet.x + bullet.width > rocket.x &&
          bullet.y < rocket.y + rocket.height &&
          bullet.y + bullet.height > rocket.y
        ) {
          gameOver = true;
        }
        return true;
      });
    }

    // Update enemy positions and check collisions with the rocket
    function updateEnemies() {
      enemies = enemies.filter((enemy) => {
        enemy.y += enemy.speed;
        if (
          enemy.x < rocket.x + rocket.width &&
          enemy.x + enemy.width > rocket.x &&
          enemy.y < rocket.y + rocket.height &&
          enemy.y + enemy.height > rocket.y
        ) {
          gameOver = true;
        }
        return enemy.y < canvas.height;
      });
    }

    // Check collisions between bullets and enemies
    function checkCollisions() {
      bullets.forEach((bullet, bIndex) => {
        enemies.forEach((enemy, eIndex) => {
          if (
            bullet.x < enemy.x + enemy.width &&
            bullet.x + bullet.width > enemy.x &&
            bullet.y < enemy.y + enemy.height &&
            bullet.y + bullet.height > enemy.y
          ) {
            // Remove bullet and enemy on collision
            bullets.splice(bIndex, 1);
            enemies.splice(eIndex, 1);
            score += 10;
            // Play explosion sound and add explosion effect
            explosionSound.currentTime = 0;
            explosionSound.play();
            addExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
          }
        });
      });
    }

    // Add an explosion effect at (x, y)
    function addExplosion(x, y) {
      explosions.push({
        x,
        y,
        radius: 0,
        maxRadius: 30 * scale,
        alpha: 1,
      });
    }

    // Update explosions (grow and fade out)
    function updateExplosions() {
      explosions = explosions.filter((explosion) => {
        explosion.radius += 1 * scale;
        explosion.alpha -= 0.03;
        return explosion.alpha > 0;
      });
    }

    // ──────────────────────────────── Drawing Functions ────────────────────────────────

    // Draw the star-field background
    function drawStars() {
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "white";
      stars.forEach((star) => {
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // Update star positions for a parallax effect
    function updateStars() {
      stars.forEach((star) => {
        star.y += star.speed;
        if (star.y > canvas.height) {
          star.y = 0;
          star.x = Math.random() * canvas.width;
        }
      });
    }

    function drawRocket() {
      ctx.drawImage(rocket.image, rocket.x, rocket.y, rocket.width, rocket.height);
    }

    function drawBullets() {
      bullets.forEach((bullet) => {
        ctx.drawImage(bullet.image, bullet.x, bullet.y, bullet.width, bullet.height);
      });
      enemyBullets.forEach((bullet) => {
        ctx.drawImage(bullet.image, bullet.x, bullet.y, bullet.width, bullet.height);
      });
    }

    function drawEnemies() {
      enemies.forEach((enemy) => {
        ctx.drawImage(enemyImage, enemy.x, enemy.y, enemy.width, enemy.height);
      });
    }

    function drawExplosions() {
      explosions.forEach((explosion) => {
        ctx.save();
        ctx.globalAlpha = explosion.alpha;
        ctx.fillStyle = "orange";
        ctx.beginPath();
        ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }

    // Draw score HUD
    function drawScore() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
      ctx.fillRect(canvas.width - 160 * scale, 10 * scale, 150 * scale, 40 * scale);
      ctx.fillStyle = "white";
      ctx.font = `${30 * scale}px Arial`;
      ctx.textAlign = "right";
      ctx.fillText(`Score: ${score}`, canvas.width - 20 * scale, 40 * scale);
    }

    // ──────────────────────────────── Main Game Loop ────────────────────────────────
    function gameLoop(timestamp) {
      if (gameOver) {
        // Save score online and show Game Over screen
        if (!playerName) playerName = "Unknown Player";
        saveScoreOnline(playerName, score);
        drawGameOverScreen();
        return;
      }

      // Update timers and spawn enemies based on interval (which may decrease as score increases)
      enemySpawnTimer += 16; // approximate time per frame (ms)
      // You can gradually lower the spawn interval based on score if desired
      if (enemySpawnTimer > enemySpawnInterval) {
        spawnEnemy();
        enemySpawnTimer = 0;
      }

      // Update game objects
      updateStars();
      moveRocket();
      updateBullets();
      updateEnemies();
      checkCollisions();
      updateExplosions();

      // Draw everything
      drawStars();
      drawRocket();
      drawBullets();
      drawEnemies();
      drawExplosions();
      drawScore();

      animationFrameId = requestAnimationFrame(gameLoop);
    }

    // ──────────────────────────────── Game Over & Restart ────────────────────────────────
    function drawGameOverScreen() {
      gameStarted = false;
      // Dark translucent overlay
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "red";
      ctx.font = `${50 * scale}px Arial`;
      ctx.textAlign = "center";
      ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 50 * scale);

      ctx.fillStyle = "white";
      ctx.font = `${25 * scale}px Arial`;
      ctx.fillText("Press ENTER to Restart", canvas.width / 2, canvas.height / 2 + 20 * scale);

      // Leaderboard link (clickable)
      const leaderboardText = "View Leaderboard";
      const leaderboardX = canvas.width / 2;
      const leaderboardY = canvas.height / 2 + 60 * scale;

      ctx.fillStyle = "blue";
      ctx.font = `${20 * scale}px Arial`;
      ctx.fillText(leaderboardText, leaderboardX, leaderboardY);

      // One-time event listener for clicking the leaderboard text
      canvas.addEventListener(
        "click",
        function handleLeaderboardClick(event) {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          const textWidth = ctx.measureText(leaderboardText).width;
          const textHeight = 20 * scale;
          if (
            x >= leaderboardX - textWidth / 2 &&
            x <= leaderboardX + textWidth / 2 &&
            y >= leaderboardY - textHeight / 2 &&
            y <= leaderboardY + textHeight / 2
          ) {
            window.open(
              "https://fluttercentral.com/games/FlightGameLeaderboard.html",
              ""
            );
          }
        },
        { once: true }
      );

      cancelAnimationFrame(animationFrameId);
    }

    function resetGame() {
      gameOver = false;
      score = 0;
      bullets = [];
      enemies = [];
      enemyBullets = [];
      explosions = [];
      rocket.x = canvas.width / 2 - rocket.width / 2;
      rocket.y = canvas.height - rocket.height - 20;
      enemySpawnTimer = 0;
      gameLoop();
    }

    // ──────────────────────────────── Firebase Leaderboard Functions ────────────────────────────────
    function saveScoreOnline(playerName, score) {
      const leaderboardRef = ref(db, "leaderboard");
      push(leaderboardRef, {
        name: playerName,
        score: score,
      })
        .then(() => {
          console.log("Score saved successfully!");
        })
        .catch((error) => {
          console.error("Error saving score:", error);
        });
    }

    function fetchLeaderboard() {
      const leaderboardRef = query(
        ref(db, "leaderboard"),
        orderByChild("score"),
        limitToLast(5)
      );
      get(leaderboardRef)
        .then((snapshot) => {
          if (snapshot.exists()) {
            let scores = [];
            snapshot.forEach((childSnapshot) => {
              scores.push(childSnapshot.val());
            });
            scores.sort((a, b) => b.score - a.score);
            drawOnlineLeaderboard(scores);
          } else {
            console.log("No leaderboard data available");
          }
        })
        .catch((error) => {
          console.error("Error fetching leaderboard:", error);
        });
    }

    function drawOnlineLeaderboard(scores) {
      // Draw leaderboard overlay
      ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
      const boxWidth = 300 * scale,
        boxHeight = 180 * scale;
      ctx.fillRect(
        canvas.width / 2 - boxWidth / 2,
        canvas.height / 2 + 50 * scale,
        boxWidth,
        boxHeight
      );
      ctx.fillStyle = "white";
      ctx.font = `${25 * scale}px Arial`;
      ctx.textAlign = "center";
      ctx.fillText(
        "Global Leaderboard",
        canvas.width / 2,
        canvas.height / 2 + 80 * scale
      );
      scores.forEach((s, i) => {
        ctx.fillText(
          `${i + 1}. ${s.name}: ${s.score}`,
          canvas.width / 2,
          canvas.height / 2 + 120 * scale + i * 30 * scale
        );
      });
    }

    // ──────────────────────────────── Start Screen & Username Input ────────────────────────────────
    document.addEventListener("DOMContentLoaded", () => {
      // Telegram WebApp integration
      if (window.Telegram && window.Telegram.WebApp) {
        console.log("✅ Telegram WebApp API detected!");
        window.Telegram.WebApp.ready();
        window.Telegram.WebApp.expand();
        const user = window.Telegram.WebApp.initDataUnsafe?.user;
        if (user) {
          window.telegramPlayerName = user.username || `User${user.id}`;
          playerName = window.telegramPlayerName;
          console.log("✅ Telegram Username:", window.telegramPlayerName);
        } else {
          console.log("❌ No user data found in Telegram WebApp.");
          window.telegramPlayerName = "Guest";
          playerName = window.telegramPlayerName;
        }
      } else {
        console.log("❌ Not running inside Telegram WebView.");
        window.telegramPlayerName = "Guest";
        playerName = window.telegramPlayerName;
      }
      drawStartScreen();
    });

    function drawStartScreen() {
      // Clear canvas and draw background stars
      drawStars();
      ctx.fillStyle = "white";
      ctx.textAlign = "center";
      ctx.font = `${18 * scale}px Arial`;
      ctx.fillText(
        "🚀 Rocket Shooting Game - V1.13 (Improved) 🚀",
        canvas.width / 2,
        canvas.height / 3 - 20
      );
      ctx.font = `${16 * scale}px Arial`;
      ctx.fillText("Double-Tap to Start", canvas.width / 2, canvas.height / 2);
      ctx.fillText("or Press Enter", canvas.width / 2, canvas.height / 2 + 40);
      ctx.fillStyle = "blue";
      ctx.font = `${15 * scale}px Arial`;
      ctx.fillText("View Leaderboard", canvas.width / 2, canvas.height / 2 + 100);

      // If the player is a guest, prompt for a username
      if (window.telegramPlayerName === "Guest") {
        showUsernameInput();
      } else {
        ctx.fillStyle = "white";
        ctx.font = `${18 * scale}px Arial`;
        ctx.fillText(`Welcome ${window.telegramPlayerName}`, canvas.width / 2, canvas.height / 3 - 70);
      }
    }

    function showUsernameInput() {
      // Remove existing overlay if any
      const existingOverlay = document.getElementById("overlay");
      if (existingOverlay) existingOverlay.remove();

      // Create full-screen overlay
      let overlay = document.createElement("div");
      overlay.id = "overlay";
      overlay.style.position = "fixed";
      overlay.style.top = "0";
      overlay.style.left = "0";
      overlay.style.width = "100vw";
      overlay.style.height = "100vh";
      overlay.style.background = "black";
      overlay.style.zIndex = "999";
      document.body.appendChild(overlay);

      // Heading for input
      let heading = document.createElement("h2");
      heading.id = "nameHeading";
      heading.innerText = "Enter Your Name";
      heading.style.position = "absolute";
      heading.style.top = "30%";
      heading.style.left = "50%";
      heading.style.transform = "translate(-50%, -50%)";
      heading.style.color = "white";
      heading.style.fontSize = "24px";
      heading.style.fontFamily = "Arial, sans-serif";
      heading.style.zIndex = "1001";
      document.body.appendChild(heading);

      // Input box
      let input = document.createElement("input");
      input.type = "text";
      input.id = "usernameInput";
      input.placeholder = "Enter your name";
      input.style.position = "absolute";
      input.style.top = "40%";
      input.style.left = "50%";
      input.style.transform = "translate(-50%, -50%)";
      input.style.padding = "12px";
      input.style.fontSize = "20px";
      input.style.border = "2px solid white";
      input.style.background = "black";
      input.style.color = "white";
      input.style.textAlign = "center";
      input.style.zIndex = "1001";
      input.style.width = "80%";
      document.body.appendChild(input);
      input.focus();

      // Adjust for keyboard on mobile
      window.addEventListener("resize", adjustForKeyboard);

      input.addEventListener("keypress", function (event) {
        if (event.key === "Enter") {
          saveUsername();
        }
      });

      // Submit button
      let button = document.createElement("button");
      button.innerText = "Save Name";
      button.style.position = "absolute";
      button.style.top = "50%";
      button.style.left = "50%";
      button.style.transform = "translate(-50%, -50%)";
      button.style.padding = "12px 24px";
      button.style.fontSize = "18px";
      button.style.cursor = "pointer";
      button.style.border = "2px solid white";
      button.style.background = "white";
      button.style.color = "black";
      button.style.zIndex = "1001";
      document.body.appendChild(button);
      button.addEventListener("click", saveUsername);
    }

    function adjustForKeyboard() {
      let input = document.getElementById("usernameInput");
      let button = document.querySelector("button");
      let heading = document.getElementById("nameHeading");

      if (window.innerHeight < 500) {
        input.style.top = "20%";
        button.style.top = "35%";
        heading.style.top = "15%";
      } else {
        input.style.top = "40%";
        button.style.top = "50%";
        heading.style.top = "30%";
      }
    }

    function saveUsername() {
      let input = document.getElementById("usernameInput");
      if (input && input.value.trim() !== "") {
        window.telegramPlayerName = input.value.trim();
        playerName = input.value.trim();
        console.log("✅ Updated Username:", playerName);
        window.removeEventListener("resize", adjustForKeyboard);
        input.remove();
        document.querySelector("button").remove();
        document.getElementById("nameHeading").remove();
        document.getElementById("overlay").remove();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        setTimeout(drawStartScreen, 100);
      }
    }

    function startGame() {
      if (!window.telegramPlayerName || window.telegramPlayerName === "Guest") {
        alert("Please enter your name before starting the game!");
        return;
      }
      if (gameStarted) return;
      gameStarted = true;
      gameOver = false;
      score = 0;
      bullets = [];
      enemies = [];
      enemyBullets = [];
      explosions = [];
      rocket.x = canvas.width / 2 - rocket.width / 2;
      rocket.y = canvas.height - rocket.height - 20;
      enemySpawnTimer = 0;
      // Clear the canvas and start the game loop
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      gameLoop();
    }

    // Initialize timing variables
    lastShotTime = 0;
    gameOver = false;
    score = 0;
  </script>
</body>
</html>
