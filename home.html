<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Rocket Shooting Game</title>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            background-color: black;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .leaderboard-link {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 20px;
            text-decoration: underline;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.2.0/firebase-app.js";
        import { getDatabase, ref, push, query, orderByChild, limitToLast, get }
          from "https://www.gstatic.com/firebasejs/11.2.0/firebase-database.js";
      
        // Firebase configuration
        const firebaseConfig = {
          apiKey: "AIzaSyBMVusLN5bhGncxW4PIYRaxqU6buujdf2k",
          authDomain: "flighgamescores.firebaseapp.com",
          databaseURL: "https://flighgamescores-default-rtdb.firebaseio.com",
          projectId: "flighgamescores",
          storageBucket: "flighgamescores.firebasestorage.app",
          messagingSenderId: "646294478907",
          appId: "1:646294478907:web:04cdba902ef2f5c5fe3c1e",
          measurementId: "G-6HXTYBD1TH"
        };
      
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        let playerName;

        // Check if running inside Telegram WebView
        if (window.Telegram && window.Telegram.WebApp) {
            window.Telegram.WebApp.expand(); // Expands the web app to full screen
            const user = window.Telegram.WebApp.initDataUnsafe.user;

            if (user) {
                const telegramUsername = user.username || `User${user.id}`;
                console.log("Telegram Username:", telegramUsername);
                
                // You can use this username in your game logic, for example:
                window.telegramPlayerName = telegramUsername;
                playerName = telegramUsername;
            }
        } else {
            console.log("Not running inside Telegram WebView");
            playerName = "123";
        }


        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let scale, gameOver, score, lastShotTime, gameStarted = false;
        let bullets = [], enemies = [], enemyBullets = [];
        let touchX = null;
        let animationFrameId;

        const rocket = {
            x: 0,
            y: 0,
            width: 50,
            height: 70,
            speed: 5,
            image: new Image()
        };
        rocket.image.src = 'MainFlight.png';

        const enemyImage = new Image();
        enemyImage.src = 'enemy.png';

        const blueBulletImage = new Image();
        blueBulletImage.src = 'Bluebullet.png';

        const redBulletImage = new Image();
        redBulletImage.src = 'Redbullet.png';

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            scale = Math.max(canvas.width / 800, 1);

            rocket.width = 60 * scale;
            rocket.height = 80 * scale;
            rocket.x = canvas.width / 2 - rocket.width / 2;
            rocket.y = canvas.height - rocket.height - 20;
            rocket.speed = 6 * scale;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        drawScore(); // Redraw the score after resizing

        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key] = true);
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        function moveRocket() {
            if (keys['ArrowLeft'] && rocket.x > 0) rocket.x -= rocket.speed;
            if (keys['ArrowRight'] && rocket.x + rocket.width < canvas.width) rocket.x += rocket.speed;
            if (keys['ArrowUp'] && rocket.y > 0) rocket.y -= rocket.speed;
            if (keys['ArrowDown'] && rocket.y + rocket.height < canvas.height) rocket.y += rocket.speed;
            
            // Fire bullets with cooldown
            const fireRate = 300;
            if (keys[' '] && Date.now() - lastShotTime > fireRate) {
                bullets.push({
                    x: rocket.x + rocket.width / 2 - 5 * scale,
                    y: rocket.y,
                    width: 10 * scale,
                    height: 20 * scale,
                    image: blueBulletImage,
                    speed: 7 * scale
                });
                lastShotTime = Date.now();
            }
        }

        function spawnEnemy() {
            const enemyWidth = 60 * scale, enemyHeight = 60 * scale;
            const x = Math.random() * (canvas.width - enemyWidth);
            
            const newEnemy = {
                x,
                y: -enemyHeight,  // Start off-screen
                width: enemyWidth,
                height: enemyHeight,
                speed: 2 * scale
            };

            enemies.push(newEnemy);

            // Fire bullet from enemy AFTER it has moved into view
            setTimeout(() => {
                if (!gameOver && newEnemy.y + newEnemy.height > 0) {  
                    enemyBullets.push({
                        x: newEnemy.x + newEnemy.width / 2 - 5 * scale,
                        y: newEnemy.y + newEnemy.height,  // Ensure it spawns at the enemy's bottom
                        width: 10 * scale,
                        height: 20 * scale,
                        image: redBulletImage,
                        speed: 5 * scale
                    });
                }
            }, 1500);  // Wait longer to ensure enemy is visible before firing
        }


        setInterval(spawnEnemy, 2000);

        function updateBullets() {
            bullets = bullets.filter(bullet => {
                bullet.y -= bullet.speed;
                return bullet.y + bullet.height > 0;
            });

            enemyBullets = enemyBullets.filter(bullet => {
                bullet.y += bullet.speed;
                if (bullet.y > canvas.height) return false;

                if (
                    bullet.x < rocket.x + rocket.width &&
                    bullet.x + bullet.width > rocket.x &&
                    bullet.y < rocket.y + rocket.height &&
                    bullet.y + bullet.height > rocket.y
                ) {
                    gameOver = true;
                }
                return true;
            });
        }

        function updateEnemies() {
            enemies = enemies.filter(enemy => {
                enemy.y += enemy.speed;

                if (
                    enemy.x < rocket.x + rocket.width &&
                    enemy.x + enemy.width > rocket.x &&
                    enemy.y < rocket.y + rocket.height &&
                    enemy.y + enemy.height > rocket.y
                ) {
                    gameOver = true;
                }

                return enemy.y < canvas.height;
            });
        }

        function checkCollisions() {
            bullets.forEach((bullet, bIndex) => {
                enemies.forEach((enemy, eIndex) => {
                    if (
                        bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y
                    ) {
                        bullets.splice(bIndex, 1);
                        enemies.splice(eIndex, 1);
                        score += 10;
                    }
                });
            });
        }

        function drawRocket() {
            ctx.drawImage(rocket.image, rocket.x, rocket.y, rocket.width, rocket.height);
        }

        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.drawImage(bullet.image, bullet.x, bullet.y, bullet.width, bullet.height);
            });
            enemyBullets.forEach(bullet => {
                ctx.drawImage(bullet.image, bullet.x, bullet.y, bullet.width, bullet.height);
            });
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                ctx.drawImage(enemyImage, enemy.x, enemy.y, enemy.width, enemy.height);
            });
        }

        function drawScore() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; // Semi-transparent background
            ctx.fillRect(canvas.width - 160 * scale, 10 * scale, 150 * scale, 40 * scale); 

            ctx.fillStyle = 'white';
            ctx.font = `${30 * scale}px Arial`;
            ctx.textAlign = 'right'; 
            ctx.fillText(`Score: ${score}`, canvas.width - 20 * scale, 40 * scale);
        }


        function gameLoop() {
            if (gameOver) {
                // Ask for player name and save score to Firebase
                if (!playerName) playerName = "Unknown Player"; // Default name if empty
                saveScoreOnline(playerName, score);

                drawGameOverScreen();
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            moveRocket();
            updateBullets();
            updateEnemies();
            checkCollisions();

            drawRocket();
            drawBullets();
            drawEnemies();
            drawScore();

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function drawGameOverScreen() {

            gameStarted = false;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = 'red';
            ctx.font = `${50 * scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 50 * scale);

            ctx.fillStyle = 'white';
            ctx.font = `${25 * scale}px Arial`;
            ctx.fillText('Press ENTER to Restart', canvas.width / 2, canvas.height / 2 + 20 * scale);

            // Add a clickable leaderboard link
            let leaderboardText = "View Leaderboard";
            let leaderboardX = canvas.width / 2;
            let leaderboardY = canvas.height / 2 + 60 * scale;

            ctx.fillStyle = 'blue';
            ctx.font = `${20 * scale}px Arial`;
            ctx.fillText(leaderboardText, leaderboardX, leaderboardY);

            // Detect click on leaderboard link
            canvas.addEventListener('click', function handleLeaderboardClick(event) {
                let rect = canvas.getBoundingClientRect();
                let x = event.clientX - rect.left;
                let y = event.clientY - rect.top;

                let textWidth = ctx.measureText(leaderboardText).width;
                let textHeight = 20 * scale; // Approximate height of text

                if (
                    x >= leaderboardX - textWidth / 2 &&
                    x <= leaderboardX + textWidth / 2 &&
                    y >= leaderboardY - textHeight / 2 &&
                    y <= leaderboardY + textHeight / 2
                ) {
                    window.open('https://fluttercentral.com/games/FlightGameLeaderboard.html', ''); // Replace with actual URL
                }
            }, { once: true });

            cancelAnimationFrame(animationFrameId);
        }


        function resetGame() {
            gameOver = false;
            score = 0;
            bullets = [];
            enemies = [];
            enemyBullets = [];
            rocket.x = canvas.width / 2 - rocket.width / 2;
            rocket.y = canvas.height - rocket.height - 20;
            gameLoop();
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                startGame();
            }
        });

        let touchStartTime = 0;
        let touchCount = 0;

        canvas.addEventListener('click', (event) => {
            let rect = canvas.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;

            let leaderboardText = "View Leaderboard";
            let textWidth = ctx.measureText(leaderboardText).width;
            let textHeight = 20 * scale;
            let leaderboardX = canvas.width / 2;
            let leaderboardY = canvas.height / 2 + 100;

            if (
                x >= leaderboardX - textWidth / 2 &&
                x <= leaderboardX + textWidth / 2 &&
                y >= leaderboardY - textHeight / 2 &&
                y <= leaderboardY + textHeight / 2
            ) {
                window.open('https://fluttercentral.com/games/FlightGameLeaderboard.html', '');
            }
        });


        let touchStartX = null;
        let touchStartY = null;

        canvas.addEventListener('touchstart', (e) => {
            touchCount++;
            if (touchCount === 2) {
                startGame();
            }
            setTimeout(() => { touchCount = 0; }, 300); // Reset double-tap detection
            
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;

            // Fire bullets if user taps without dragging
            if (e.touches.length === 1) {
                fireBullet();
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];

            if (touchStartX !== null && touchStartY !== null) {
                let deltaX = touch.clientX - touchStartX;
                let deltaY = touch.clientY - touchStartY;

                rocket.x += deltaX;
                rocket.y += deltaY;

                touchStartX = touch.clientX;
                touchStartY = touch.clientY;

                // Keep rocket within screen boundaries
                rocket.x = Math.max(0, Math.min(canvas.width - rocket.width, rocket.x));
                rocket.y = Math.max(0, Math.min(canvas.height - rocket.height, rocket.y));
            }
        });

        canvas.addEventListener('touchend', () => {
            touchStartX = null;
            touchStartY = null;
        });

        // Fire bullets on tap (without dragging)
        function fireBullet() {
            if (bullets.length < 5) {
                bullets.push({
                    x: rocket.x + rocket.width / 2 - 5 * scale,
                    y: rocket.y,
                    width: 10 * scale,
                    height: 20 * scale,
                    image: blueBulletImage,
                    speed: 7 * scale
                });
            }
        }

        function saveScoreOnline(playerName, score) {
            const leaderboardRef = ref(db, "leaderboard");
            push(leaderboardRef, {
                name: playerName,
                score: score
            }).then(() => {
                console.log("Score saved successfully!");
            }).catch(error => {
                console.error("Error saving score:", error);
            });
        }


        function fetchLeaderboard() {
            const leaderboardRef = query(ref(db, "leaderboard"), orderByChild("score"), limitToLast(5));
            get(leaderboardRef).then(snapshot => {
                if (snapshot.exists()) {
                    let scores = [];
                    snapshot.forEach(childSnapshot => {
                        scores.push(childSnapshot.val());
                    });
                    scores.sort((a, b) => b.score - a.score); // Sort in descending order
                    drawOnlineLeaderboard(scores);
                } else {
                    console.log("No leaderboard data available");
                }
            }).catch(error => {
                console.error("Error fetching leaderboard:", error);
            });
        }


        function drawOnlineLeaderboard(scores) {
            const ctx = document.getElementById('gameCanvas').getContext('2d');
            const scale = Math.max(window.innerWidth / 800, 1);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(window.innerWidth / 2 - 150 * scale, window.innerHeight / 2 + 50 * scale, 300 * scale, 180 * scale);
            
            ctx.fillStyle = 'white';
            ctx.font = `${25 * scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('Global Leaderboard', window.innerWidth / 2, window.innerHeight / 2 + 80 * scale);

            scores.forEach((s, i) => {
                ctx.fillText(`${i + 1}. ${s.name}: ${s.score}`, window.innerWidth / 2, window.innerHeight / 2 + 120 * scale + i * 30 * scale);
            });
        }

        function drawStartScreen() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Set text styles
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';

            // Welcome message (fixed incorrect subtraction)
            const playerName = window.telegramPlayerName || "Player"; // Default to "Player" if not set
            ctx.font = `${35 * scale}px Arial`;
            ctx.fillText(`Welcome ${playerName}`, canvas.width / 2, canvas.height / 3 - 70); // Adjusted positioning

            // Game title
            ctx.font = `${40 * scale}px Arial`;
            ctx.fillText('ðŸš€ Rocket Shooting Game - V1.3 ðŸš€', canvas.width / 2, canvas.height / 3 + 20);

            // Instructions
            ctx.font = `${25 * scale}px Arial`;
            ctx.fillText('Double-Tap to Start', canvas.width / 2, canvas.height / 2);
            ctx.fillText('or Press Enter', canvas.width / 2, canvas.height / 2 + 40);

            // Leaderboard link
            ctx.fillStyle = 'blue';
            ctx.font = `${20 * scale}px Arial`;
            ctx.fillText('View Leaderboard', canvas.width / 2, canvas.height / 2 + 100);
        }


        function startGame() {
            if (gameStarted) return;
            gameStarted = true;
            gameOver = false;
            score = 0;
            bullets = [];
            enemies = [];
            enemyBullets = [];

            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas before restarting
            gameLoop();
        }

        lastShotTime = 0;
        gameOver = false;
        score = 0;
        drawStartScreen();

    </script>
</body>
</html>
